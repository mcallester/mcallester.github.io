\input /users/davidmcallester/icloud/tex/SlidePreamble
\input /users/davidmcallester/icloud/tex/preamble

\begin{document}

{\Huge

  \centerline{\bf TTIC 31230, Fundamentals of Deep Learning}

  
\bigskip

\centerline{David McAllester, Autumn  2024}


\vfill

\centerline{\bf The Foundations of Mathematics}

\slidetwo{Zermelo-Fraenkel Set Theory}{with the Axiom of Choice (ZFC)}

ZFC is a set of nine axioms in first order logic with equality and a single relation $\in$.

\vfill
ZFC plus a plus a large cardinal axiom defines the set of all possible mathematical theorems.

\vfill
A theorem of mathematics is a formula in the language of set theory that is provable using the nine axioms of ZFC, a large cardinal axiom,
and the inference rules of first order logic.

\slide{First Order Logic}

A first order language is defined by the Boolean operations $\vee$, $\wedge$, $\Rightarrow$ and $\neg$ (and, or, implies and not), the quantifiers $\forall$ and $\exists$ (forall and exists) the equality
symbol $=$, and a certain set of function and relation symbols.

\vfill
For example, the first order language of Peano arithmetic is defined by the constant $0$ (zero) and function $s$ (successor) of one argument.


\slide{First Order Logic}

The first order language of Peano arithmetic is defined by the constant $0$ (zero) and function $s$ (successor) of one argument.

\vfill
The axioms of Peano arithmetic are:

\vfill
\begin{enumerate}
\item $\forall x,y \;\;s(x)=s(y) \Rightarrow x=y$

\vfill
\item $\forall x\;\;s(x) \ne 0$

\vfill
\item For any formula $\Phi[x]$:

$$(\Phi[0] \wedge \forall x \;\Phi[x]\Rightarrow \Phi[s(x)]) \Rightarrow \forall x \;\Phi[x]$$
\end{enumerate}

\slide{Set Theory}

In set theory we have only the single relation $\in$.

\vfill
The axioms imply that there exists an empty set $\emptyset$.

$$\exists x\; \forall y \;y \not\in x$$

\vfill
For any set $x$ we have the set containing $x$.

\vfill
We also have an infinite set

$$\exists x \; \emptyset\in x \wedge \forall y\; \;y \in x \Rightarrow \{y\} \in x$$

\vfill
We can define the natural numbers, the integers, the rationals, the reals and all the structures of mathematics
as particular sets within the universe of sets.

\slide{The Universe $V$}

The universe of all sets is typically written as $V$.

\vfill
In the 1870s Cantor proposed to define $V$ by stating that any formula can be used to name a set.
$$\mbox{for any formula $\Phi[y]$:}\;\;\;\exists x\;\forall y \;y \in x \Leftrightarrow \Phi[y]$$

\vfill
This is called the axiom of {\bf naive comprehension}.

\vfill
Naive comprehension leads to Russell's paradox

$$\exists x\;\forall y\;\;y \in x \Leftrightarrow y \not\in y$$

$$x \in x \Leftrightarrow x \not\in x$$

\slide{Nine ZFC Axioms (The First Four)}

{\bf Extensionality:} If two sets have the same members then they are the same set.

\vfill
{\bf Foundation:} $\in$ is a well-founded relation (every set contains a least member under the order $\in$).

\vfill
{\bf Restricted Comprehension:} For any $x \in V$, and any formula $\Phi[y]$, $V$ contains $\{y\in x:\;\Phi[y]\}$

\vfill
{\bf Infinity:} $V$ contains an infinite set:
$$\exists x \; \emptyset\in x \wedge  \; \forall y\; \;y \in x \Rightarrow \{y\} \in x$$

\slide{The Nine ZFC Axioms (The Rest)}

{\bf Power Set:} For any set $x \in V$ we have that $V$ contains the set of subsets of $x$, denote ${\cal P}(x)$.

\vfill
{\bf Pairing and Union:} We can form two element sets and take the union of the elements of a set.

\vfill
{\bf Replacement:} For any set $x \in V$, and any function $f$ from $x$ into $V$, the set $\{f(y):\;y \in x\}$ is also in $V$.

\vfill
{\bf Choice:} If $(\forall x \exists y\;\Phi(x,y)) \Rightarrow \exists f \forall x \;\Phi(x,f(x))$.

\slide{The Large Cardinal Axiom}

A Grothendieck universe is a set $\tilde{V}$ with all the properties of $V$ but is a member of ``the real''(larger) $V$.

\vfill
The large cardinal axiom is equivalent to the statement that $V$ contains a Grothendieck universe.

\vfill
This is equivalent to the statement that large cardinals exist.

\vfill
Grothendieck assumed the existence of such a universe in proving certain classification theorems for topological spaces.

\vfill
Large cardinal theory was a major topic in set theory for many decades.

\slide{What is wrong with Set Theory?}

The fundamental issue with set theory is that it ignores fact that mathematical statements
involve a notion of grammaticality.

\vfill
We can add two numbers but we cannot add a word to a number.

\vfill
The representation of the natural numbers where zero is the empty set and $s(x)$ is $\{x\}$ is completely arbitrary.

\vfill
The natural numbers (and all mathematical structures) should be defined in a way that is independent of any particular
representation.

\slide{Grammar and Isomorphism}

\vfill
The idea of isomorphic graphs seems intuitively clear.

\vfill
For any two isomorphic graphs $G$ and $G'$ and for any {\bf Grammatically Well Formed} statements $\Phi(g)$ about an arbitrary graph $g$
we have $\Phi(G) \Leftrightarrow \Phi(G')$.

\slide{General First Order Logic Provides Grammar}

The first order language  of {\bf zero} and {\bf succ} has terms and formulas
defined by the following grammar.

$${\color{red} t
::= \mathrm{variable} \;||\; \mathrm{zero} \;||\; \mathrm{succ}(t)}$$

$${\color{red} \Phi ::= t_1=t_2 \;||\; \forall x\; \Phi[x] \;||\; \exists x\; \Phi[x] \;||\; \Phi_1 \vee \Phi_2 \;||\; \Phi_1 \wedge \Phi_2 \;||\; \neg \Phi}$$


\slide{Signatures}

A first order language is defined by a set of constant, function and predicate symbols each with a specified
arity (number of arguments).

\vfill
The set of constant, function and predicate symbols together with their arity is called the {\bf signature} of the language.

\vfill
The signature defines a gammar specifying a set of {\bf grammatically well-formed} terms and formulas.

\slide{Multi-Sorted Logic}

{\huge
A multi-sorted signature consists of a set of ``sorts'' and a specification $f\!:\!\tau$ of a type $\tau$ for the each symbol $f$ of the language.

\vfill
A vector space has two sorts --- one for scalars and one for vectors.
The multiplication-by-a-scalar operator has the type specification

$${\color{red}\mathrm{SVProd}: \mathrm{scalar} \times \mathrm{vector} \rightarrow \mathrm{vector}}$$
}

\slide{Higher Order Multi-Sorted Logic}

The ``simple types'' over a given set of sorts consist of the expressions that can be constructed from the sorts, the constant type bool, and
the type constructors $\times$ and $\rightarrow$.
$${\color{red} \tau ::= \mathrm{sort} \;||\; \mathrm{bool} \;||\; \tau_1 \times \tau_2 \;||\; \tau_1 \rightarrow \tau_2}$$


\vfill
A topological space has one sort --- the points --- and an (second order) predicate {\bf open} which has the type specification
$${\color{red}\mathrm{open}:(\mathrm{point}\rightarrow\mathrm{bool})\rightarrow\mathrm{bool}}$$

\vfill
The induction axiom for arithmetic can be written as
$${\color{red}\forall P\!:\!\left(N\rightarrow\mathrm{bool})\;(P(\mathrm{zero}) \wedge \forall x\!:\!N\;P(x)\rightarrow P(s(x))\right) \rightarrow \forall x\!:\!N \;P(x)}$$

\slide{Extending Terms with Pairs and Functions}

As in programming languages, we now extend terms to include pairs, projections of pairs, functions, and applications of functions.

\vfill
Pairing {\color{red} $\tuple{s,u}$} and projections {\color{red} $\pi_1(e)$} and {\color{red} $\pi_2(e)$}.

\vfill
$\lambda$-expressions (functions) {\color{red} $\lambda\; \intype{x}{\tau}\;e[x]$} and applications {\color{red} $f(e)$}.

\vfill
It is not difficult to define the grammar of this extended set of terms.

\slide{Signature-Axiom Classes}

Common mathematical concepts can be defined as models of a multi-sorted signature satifying given axioms written in the language defined
by the signature.

\vfill
Intuitively we have a ``data type'' specified by the signature.  An instance of this data type is a model
(particular data) specifying a value for each sort
and a value for each declared symbol (consistent with the type declarations).

\vfill
We also have ``axioms'' which are the properties that the data must satisfy.  We assume the axioms to be grammaticaly well-formed (well typed).

\slide{Signature-Axiom Classes}

Two structures of the same signature are isomorphic if there exists a system of bijections between the sorts which carry the data of one to the data of the other.

\vfill
It is straightforward to define the notion of ``carry'' for simply typed language constants.

\vfill
It is also straightforward to prove that
if two models of the same signature are isomorphic then they satisfy the same (grammatical) formulas.

\slide{The Set-Class Distinction}

All of mathematics can be translated into set theory.  A particular graph can be represented by a set.

\vfill
However, any set can be taken to be a node in a graph. There are at least as many graphs as there are sets.

\vfill
This implies that the collection of all graphs is not a set --- it is a {\bf proper class}, a subset of $V$ that is not a member of $V$.

\slide{Functors: Functions Between Classes}

We want a formal language with strict grammar that includes expressions for functions between classes.

\vfill
We want that isomorphic graphs have the same graph Laplacian because the definition of the graph Laplacian is grammatically well-formed (well typed).

\vfill
We want that isomorphic topological manifolds have isomorphic homotopy groups because the definition of the homotopy group is grammatically well-formed (well typed).

\vfill
Neither set theory (Mizar) nor higher order logic (Isabelle/HOL) support this.

\slide{The Substitution of Isomorphics}

~ \hfill\unnamed
    {
      \ant{\Gamma \models f:\sigma \rightarrow \tau}
      \ant{\Gamma \models u =_\sigma v}
    }{
      \ant{\Gamma \models f(u) =_\tau f(\sigma)}
      }
\hfill ~

\slide{The Importance of Isomorphism:}{Classification}

Classification is a central objective of mathematics.  Classifying the finite groups, or topological manifolds, or differentiable manifolds, or Lie groups.

\vfill
Classification is ``up to isomorphism''.

\vfill
We can expect an autonomous AI mathematician to naturally be oriented toward classification problems.

\slidetwo{The Importance of Isomorphism:}{Representation}

Any two three-dimensional vector spaces over the reals are isomorphic (although there is no natural or canonical isomorphism).

\vfill
$\mathbb{R}^3$, defined as the set of triples of real numbers, is a representation of a three dimentional vector space over the reals.

\vfill
``Representation theory'' is the study of the representation of groups as linear operators on vector spaces.

\slidetwo{The Importance of Isomorphism:}{Cryptomorphism}

People immediately recognize when two different types are ``the same'' or ``provide the same data''.

\vfill
A group can be defined in terms of the group operation, the identity element, and the inverse operation, or alternatively, just
the group operation.

\vfill
Birkhoff (1967) called the relationship between these two fomulations of group a cryptomorphism.

\vfill
Two classes $\sigma$ and $\tau$ are cryptomorphic if there exists well-formed functors $\intype{F}{\sigma \rightarrow \tau}$
and $\intype{G}{\tau \rightarrow \sigma}$ whose composition is the identity.

\slidetwo{The Importance of Isomorphism:}{Symmetry}

Any $x$ of type $\tau$ has a $\tau$ symmetry group --- the set of $\tau$-automorphisms of $x$ (isomorphisms of $x$ with itself).  For example a geometric
circle has rotational and reflective symmetries.

\vfill
If $x\!:\!\tau$ and $y\!:\!\sigma$ are $\tau$-$\sigma$-cryptomorphic then the $\tau$ symmetry group of $x$ must be isomorphic (as a permutation group) to the $\sigma$ symmetry group of $y$.

\vfill
If we treat cryptomorphic objects as just different expressions of ``the same data'' then an object has no natural or canonical structure beyond its symmetry group.

\slide{Dependent Type Theory}

For a type system to support the substitution of isomorphics we need types for signature-axiom classes.

\vfill
While having a type ``graph'' seems natural in an object-oriented programming language, the type ``planar graph'' typically cannot be defined in the type system.

\vfill
A typical object-oriented programming language supports signatures but not statically checked (compile time checked) axioms.

\vfill
Dependent Type theory (Lean) supports statically checked signature-axiom types.

\slide{Dependent Function Types}

$\Pi_{x:\tau}\;\sigma[x]$ is the type of functions that maps $x$ of type $\tau$ to a value of type $\sigma[x]$.

\vfill
$(\lambda\; \intype{x}{\mathrm{int}}\;x+5)\!:\!\Pi_{x:\mathrm{int}}\;(>(x))$

\slide{Dependent Function Type Inference Rules}

~ \hfill\unnamed
    {
      \ant{\Gamma;x\!:\!\tau \vdash e[x]\!:\!\sigma[x]}
    }{
      \ant{\Gamma \vdash (\lambda\;x\!:\!\tau \;e[x])\!:\! \Pi_{x:\tau}\;\sigma[x]}
      }
\hfill ~

~ \hfill\unnamed
    {
      \ant{\Gamma \vdash f\!:\! \Pi_{x:\tau}\;\sigma[x]}
      \ant{\Gamma \vdash e\!:\! \tau}
    }{
      \ant{\Gamma \vdash f(e)\!:\!\sigma[e]}
      }
\hfill ~

\slide{Dependent Pair Types}

$\Sigma_{x:\tau}\;\sigma[x]$ is the type of pairs $(x,y)$ with $x:\tau$ and $y:\sigma[x]$.

\vfill
For $\intype{x}{\mathrm{int}}$ we have $(x,x+5)\!:\!\Sigma_{x:\mathrm{int}}\;(>(x))$.

\slide{Dependent Pair Type Inference Rules}

~ \hfill\unnamed
    {
      \ant{\Gamma; \vdash \intype{e}{\tau}}
      \ant{\Gamma; \vdash \intype{w}{\sigma[e]}}
    }{
      \ant{\Gamma \vdash (e,w)\!:\! \Sigma_{x:\tau}\;\sigma[x]}
      }
\hfill ~

~ \hfill\unnamed
    {
      \ant{\Gamma \vdash e\!:\! \Sigma_{x:\tau}\;\sigma[x]}
    }{
      \ant{\Gamma \vdash \pi_1(e)\!:\!\tau}
      \ant{\Gamma \vdash \pi_2(e)\!:\!\sigma[\pi_1(e)]}
      }
\hfill ~

\slide{Propositions as Types}

In Lean propositions (Boolean formulas) are represented by types.

\vfill
$\forall \intype{x}{\tau} \;\Phi[x]$ is represented by the type $\Pi_{x:\tau}\;\sigma[x]$.

\vfill
$\exists \intype{x}{\tau} \;\Phi[x]$ is represented by the type $\Sigma_{x:\tau}\;\sigma[x]$.

\vfill
Types are classified into universes $U_0$, $U_1$, $U_2$, $\ldots$ where type in $U_0$ are ``propositions'',
types in $U_1$ are ``sets'', types in $U_2$ are ``classes'', and types $U_i$ for $i > 2$ are ever larger Grothendieck universes.

\slide{Propositions as Types: the Good News}

\vfill
Reducing all of mathematics to type inference rules is extremely compact (elegant?).

\vfill
Much more compact than the inference rules of first order logic plus the nine axioms of ZFC plus a large cardinal axiom.

\vfill
It also has the effect of supporting signature-axiom classes as first class types where the axioms are statically checked (explained below).

\vfill
The validity of the substitution of isomorphics was proved for Martin-L\"{o}f type theory, from which Lean is derived, by Hofmann and Streicher in 1995.

\slide{The Bad News: Constructivism}
A proposition is a type whose elements are the proofs of the statement represented by the type.

\vfill
A proposition type is ``true'' if it is ``inhabited'' ---
there exists an element of the type (proof of the proposition).

\vfill
The proposition $\forall\;\intype{P}{\mathrm{Prop}}\;P \vee \neg P$ (often called the ``excluded middle'') is rejected.

\vfill
Proof by contradiction is not allowed.

\vfill
The distinction between truth and provability is lost (G\"{o}del's incompleteness theorems).

\slide{Getting Around Constructivism}

Mathematicians that use Lean get around constructivist limitations by using extensions of constructive logic that provide
the excluded middle and the axiom of choice.

\vfill
However, it turns out there is no need for propositions as types or constructivism.

\vfill
There is no problem with simply using Boolean propositions from the start.

\slide{Semantics}

Constructive logic is specified by inference rules.

\vfill
Following Tarski (1933) we have specified logics {\bf semantically}.

\vfill
We write $\Sigma \models \Phi$ to mean that $\Phi$ is true in all models of $\Sigma$.

\vfill Semantics defines soundness and completeness and is needed to formulate G\"{o}del's incompleteness theoerms.

\vfill
We will continue to work semantically and simply generalize a little further the logic developed so far.


\slide{Recall Multi-Sorted Logic}

{\huge
A multi-sorted signature consists of a set of ``sorts'' and a specification $f\!:\!\tau$ of a type $\tau$ for the each symbol $f$ of the language.

\vfill
A vector space has two sorts --- one for scalars and one for vectors.
The multiplication-by-a-scalar operator has the type specification

$${\color{red}\mathrm{SVProd}: \mathrm{scalar} \times \mathrm{vector} \rightarrow \mathrm{vector}}$$
}

\slide{First Class Sorts}

In a programming language something is ``first class'' if it can be passed as an argument to a procedure and included as a value in data structues.

\vfill
A group contains its sort as part of its data (the set of group elements).

\vfill
To define the type ``group'' we need sorts to be included in objects --- we need first class sorts.

\slide{Recall Dependent Pair Types}

\vfill
To support first class sorts we now include {\color{red} $\mathrm{set}$} as a type so that we can declare a sort $s$ with
{\color{red}$s:\mathrm{set}$}.

\vfill
We generalize {\color{red} $\sigma \times \tau$} to {\color{red} $\Sigma_{\intype{x\;}{\;\sigma}}\;\tau[x]$} which denotes the set of all pairs $\tuple{x,y}$ with $x \in \sigma$ and $y \in \tau[x]$.

$${\color{red} \mathrm{magma}: \Sigma_{s:\mathrm{set}} [s\times s \rightarrow s]}$$

\slide{Recall Dependent Function Types}

We generalize {\color{red} $\sigma \rightarrow \tau$} to {\color{red} $\Pi_{\intype{x\;}{\;\sigma}}\;\tau[x]$} which denotes the set of all functions $f$ such that the domain of
$f$ is $\sigma$ and for all $x \in \sigma$ we have $f(x) \in \tau[x]$.

\vfill
$${\color{red} \mathrm{\mathrm{cons}}: \Pi_{\alpha:\mathrm{set}}\; (\alpha \times \mathrm{listof}(\alpha)) \rightarrow \mathrm{listof}(\alpha)}$$

\slide{Axioms}

Axioms can be incoporated into the type system with ``some such that'' types technically known as {\bf restriction types}.

\vfill
The some-such-that type {\color{red}$S_{x:\tau}\;\Phi[x]$} denotes the type of those values $x:\tau$ satisfying the ``axiom'' $\Phi[x]$.

\vfill
$${\color{red} \mathbf{Group} \; \equiv \; \Sigma_{\intype{s\;}{\;\mathrm{Set}}}\;S_{\intype{f\;}{\; s\times s \rightarrow s}}\;\Phi[s,f]}$$
\vfill

\slide{Constructive Logic ``Axioms''}

It seems natural to represent a group as a signature-axiom class.

$$\mathbf{Group} \; \equiv \; \Sigma_{\intype{s\;}{\;\mathrm{Set}}}\;{\color{red} S}_{\intype{f\;}{\; s\times s \rightarrow s}}\;\Phi[s,f]$$

\vfill
In constructive type theories one replaces the restriction type
with a pair type.

$$\mathbf{Group} \; \equiv \; \Sigma_{\intype{s\;}{\;\mathrm{Set}}}\;{\color{red} \Sigma}_{\intype{f\;}{\; s\times s \rightarrow s}}\;\Phi[s,f]$$

\vfill
Here a proof of the axioms must always be given as part of the data of the group.


\slide{The Signature-Axiom Distinction in Programming}

\vfill
In a typed programming language a procedure is declared by specifying types for its arguments and return value.  This declaration is called the ``signature'' of the procedure.

\vfill
Programming languages also support ``assertions'' --- run-time checks on program invariants.  For example, one might assert that at this point
in the program the variable $x$ is an even number.

\vfill
Compile-time checking of assertions is undecidable. Assertions become run-time checks.


\slide{Alfred}

Alfred, named for Alfred Tarski, is an under-development system intended to compete with Lean.

\vfill
Any competitive advantage over Lean will be due to the level of automation.  Time will tell ...


\slide{The Signature-Axiom Distinction in Alfred}

Alfred has a decidable {\bf signature-checking} algorithm for the type system defined here analogous
to type checking in programming language with run-time assertions.

\vfill
For a mathematical verification system we also want {\bf axiom-checking}. If $f$ is a functor taking a group as an argument
we want to check that in any application $f(G)$ we have that $G$ is a group.

\vfill
This is analogous to verifying the run-time assertions in a computer program.

\slide{Handling Undecidability}

Alfred has a quickly terminating but incomplete axiom-checker.  We make this as strong as possible while preserving quick termination.

\vfill
If the axiom-checker fails to prove that $G$ is a group we can first provide an explicit proof.

\slide{Variants of Dependent Type Theory}

\vfill
I will reserve the term ``dependent type theory'' for type system supporting signature-axiom classes as types and
supporting the substitution of isomorphics.

\vfill
In practice such a system should be given a ZFC-complete inference mechanism (rules or algorithms).

\vfill
Just as with typed programming languages, among dependent type theories the choice of particular language features matters.

\vfill
Of particular interest is object-oriented type systems.


\slidetwo{Speculation:}{The Grammar of Mathematical Natural Language}

Just as in all human languages, human mathematical language has grammar.

\vfill
Dependent type theory can be interpreted as a formal treatment of the grammar of the natural language of mathematics.

\slidetwo{Speculation:}{Object-Oriented Everything}
Modern programming languages support object-oriented programming.

\vfill
Mathematics is object-oriented in the sense that one deals with classes, such as the class of groups, and instances.

\vfill
Class-instance structure (object orientation) underlies natural language semantics (Fillmore 1976).

\vfill
Perhaps large language models will eventually make a transition from the transformer to an object-oriented archiecture.


\slidetwo{Speculation:}{What is an Electron?}

If we view cryptomorphic objects as ``the same data'', and we view objects with the same symmetry group as cryptomorphic,
then a mathematical object has no natural or canonical structure beyond its symmetry group.
It then seems natural that an electron (or the value space of the electron field) has no identifiable structure
beyond its symmetry group.



\slide{Summary: The Substitution of Isomorphics}

\vspace{-.5in}
~ \hfill\unnamed
    {
      \ant{\Gamma \models f:\sigma \rightarrow \tau}
      \ant{\Gamma \models u =_\sigma v}
    }{
      \ant{\Gamma \models f(u) =_\tau f(\sigma)}
      }
\hfill ~

\slide{END}

}
\end{document}


\slide{Some History: Bourbaki}

Bourbaki (1939) defined ``structure'' and isomorphism.

\vfill
However, the notion of structure is not as general as that of dependent type theory and,
more significantly, Bourbaki did not define the grammatically correct class of expressions for which substitution holds.

\slide{Some History: Type Theory}

Type theory appeared in Russel and Whitehead's Principia Mathematica (1910).

\vfill
Dependent type theory grew out of Brouwer's (1914) program of constructive mathematics.
Constructive mathematics has been largely ignored by mathematicians
but survives in the study of types for programming languages.

\vfill
Dependent type theory reached its modern form in Marten-L\"{o}f type theory (1972),
and Coq (1989), the ancestor of Lean (2010).

\vfill
The substitution of isomorphics was formulated in the groupoid model of Martin-L\"{o}f type theory (Hofmann and Streicher, 1995).

\slide{Misguided (IMHO) Trends in Type Theory}

Constructivism: Constructivism is largely ignored by practicing mathemticians. Dependent type theory is more natural without it.

\vfill
The restriction in Coq and Lean that every object has a unique type contradicts mathematical practice and should
be dropped --- an Abelian group is a group and a Lie group is a group.


\vfill
Homotopy type theory is not taken seriously and should be dropped.  Isomorphism is based on bijections not
homotopy paths.

